BFS 使用Queue
三要素：QUEUE pop 以及visited
1 对于最小路径问题，求最短路径不管是图，还是其他step
bfs适应性很强 : 使用queue while queue 作为标志
def func(grid):
    if grid[0][0]==1 or grid[-1][-1]==1:
       return -1
    if len(grid)<=2:
       return len(grid)
    queue=[(0,0,1)]
    grid[0][0]=1
    while queue:
       i,j,s=queue.pop(0)
       for i1,j1 in [(),(),...]:
           if i+i1==len(grid)-1 and j+j1==len(grid)-1:
              return step+1
           if 0<=i+i1<len(grid) and 0<=j+j1<len(grid) and grid[i+i1][j+j1]==0:
              grid[i+i1][j+j1]=1
              queue.append((i+i1,j+j1,s+1))
    return -1
            
    

2 整数最少分成的平方数     二叉树层级遍历  
def func(nums):
    Q=collections.deque()
    visited=set()
    step=1
    Q.append(nums)
    while Q:
         n=len(Q)
         for i in range(n):
             x=Q.popleft()
             for y in range(1,int(sqrt(nums)+1)):
                 t=x-y**2
                 if t==0:
                    return step
                 elif t not in visited:
                    visited.add(t)
                    Q.append(t)   #####注意需要添加新的queue值
         step+=1
          return step
          
 3 层级遍历二叉树
 def func(root):
 queue=collections.deque()
 queue.append(root)
 res=[]
 if not root:
    return []
 while queue:
       level=[]
       for i in range(len(queue)):
           r=queue.popleft()
           level.append(r.val)
           if not r.left:
              queue.append(r.left)
           if not r.left:
              queue.append(r.right)
        
        res.append(level)
 4 求二叉树层级最大值
 def func(root):
     queue=collections.deque()
     queue.append(root)
     res=[]
     while queue:
           max1=float('-inf')
           for i in range(len(queue)):
               r=queue.popleft()
               
               max1=max(max1,r.val)
               if not r.left:
              queue.append(r.left)
               if not r.left:
              queue.append(r.right)
           res.append(max1)
     return res
     
5 岛屿与陆地最大的距离（指最小的距离）
def func(grid):
    n=len(grid)
    step=0
    queue=[[i,j] for i in range(n) for j in range(j) if grid[i][j]==1]
    if len(queue)==0 or len(queue)==n**2:
       return -1
    while queue:
          for i in range(len(queue)):
              x,y=queue.popeleft()
              for x1,y1 in [()....]:
                  if 0<x+x1<n and 0<y+y1<n and grid[x+x1][y+y1]==0:
                     
                     grid[x+x1][y+y1]==-1
                     queue.append([x+x1,y+y1])
              step+=1
          return step-1 #######注意这里曾多加了一个
          
    
     
深度搜索 dfs
1 
           
           
       
           
          
  

