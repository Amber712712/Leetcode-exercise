BFS 使用Queue
1 对于最小路径问题，求最短路径不管是图，还是其他step
bfs适应性很强 : 使用queue while queue 作为标志
def func(grid):
    if grid[0][0]==1 or grid[-1][-1]==1:
       return -1
    if len(grid)<=2:
       return len(grid)
    queue=[(0,0,1)]
    grid[0][0]=1
    while queue:
       i,j,s=queue.pop(0)
       for i1,j1 in [(),(),...]:
           if i+i1==len(grid)-1 and j+j1==len(grid)-1:
              return step+1
           if 0<=i+i1<len(grid) and 0<=j+j1<len(grid) and grid[i+i1][j+j1]==0:
              grid[i+i1][j+j1]=1
              queue.append((i+i1,j+j1,s+1))
    return -1
            
    

2 整数最少分成的平方数
def func(nums):
    Q=collections.deque()
    visited=set()
    step=1
    Q.append(nums)
    while Q:
         n=len(Q)
         for i in range(n):
             x=Q.popleft()
             for y in range(1,int(sqrt(nums)+1)):
                 t=x-y**2
                 if t==0:
                    return step
                 elif t not in visited:
                    visited.add(t)
                    Q.append(t)   #####注意需要添加新的queue值
         step+=1
          return step

